package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where declarations will be by DeclarationVisitor Class Statements will be resolved by
 * StatementVisitor Class Expressions will be resolved by ExpressionVisitor Class
 */

public final class ParseTreeLower {
  private final DeclarationVisitor declarationVisitor = new DeclarationVisitor();
  private final StatementVisitor statementVisitor = new StatementVisitor();
  private final ExpressionVisitor expressionVisitor = new ExpressionVisitor();
  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   * 
   * @return a {@link DeclarationList} object representing the top-level AST.
   */
  public DeclarationList lower(CruxParser.ProgramContext program) {
    ArrayList<Declaration> list = new ArrayList<Declaration> ();

    symTab.enter();
    for(CruxParser.DeclarationContext context: program.declarationList().declaration()) {
      Declaration node = context.accept(declarationVisitor);
      list.add(node);
    }

    symTab.exit();
    return new DeclarationList(makePosition(program), list);
  }


  /**
   * Lower statement list by lower individual statement into AST.
   * 
   * @return a {@link StatementList} AST object.
   */
  private StatementList lower(CruxParser.StatementListContext statementList) {
    ArrayList<Statement> list = new ArrayList<Statement> ();

    for(CruxParser.StatementContext context: statementList.statement()) {
      Statement node = context.accept(statementVisitor);
      list.add(node);
    }

    return new StatementList(makePosition(statementList.getParent()), list);
  }

  /**
   * Similar to {@link #lower(CruxParser.StatementListContext)}, but handles symbol table as well.
   * 
   * @return a {@link StatementList} AST object.
   */
   private StatementList lower(CruxParser.StatementBlockContext statementBlock) {
     symTab.enter();

    StatementList stList = new StatementList(null, new ArrayList<Statement>());

     if (statementBlock != null) {
       stList = lower(statementBlock.statementList());
     }

     symTab.exit();

     return stList;

   }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclarationVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}
     * 
     * @return an AST {@link VariableDeclaration}
     */

     @Override
     public VariableDeclaration visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx) {

       Symbol symbol = symTab.add(makePosition(ctx), ctx.Identifier().getText(), new IntType());
//       System.out.println("Here end");

       return new VariableDeclaration(makePosition(ctx), symbol);
     }


    /**
     * Visit a parse tree array declaration and creates an AST {@link ArrayDeclaration}
     * 
     * @return an AST {@link ArrayDeclaration}
     */

     @Override
     public Declaration visitArrayDeclaration(CruxParser.ArrayDeclarationContext ctx) {
      //  public ArrayDeclaration(Position position, Symbol symbol) {

       Type argType = (ctx.type().getText().equals("int")) ? new IntType() : new BoolType();

       String identifier = ctx.Identifier().getText();

       String arSize = ctx.Integer().getText();

       int size = Integer.parseInt(arSize);

       Symbol arrSymb = symTab.add(makePosition(ctx), identifier, new ArrayType(size, argType));

       return new ArrayDeclaration(makePosition(ctx), arrSymb);
     }

    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     * 
     * @return an AST {@link FunctionDefinition}
     */

    @Override
    public Declaration visitFunctionDefinition(CruxParser.FunctionDefinitionContext ctx) {

      Type type = (ctx.type().getText().equals("int")) ? new IntType() : new VoidType();

      TypeList tl = new TypeList();

      for(CruxParser.ParameterContext context: ctx.parameterList().parameter()) {


        Type argType = (context.type().getText().equals("int")) ? new IntType() : new BoolType();
        tl.append(argType);
      }

      Symbol symbol = symTab.add(makePosition(ctx), ctx.Identifier().getText(), new FuncType(tl, type));

      ArrayList<Symbol> paramList = new ArrayList<Symbol> ();

      symTab.enter();

      for(CruxParser.ParameterContext context: ctx.parameterList().parameter()) {


        Type argType = (context.type().getText().equals("int")) ? new IntType() : new BoolType();

        var parm = symTab.add(makePosition(ctx), context.Identifier().getText(), argType);
        paramList.add(parm);
      }

      var statementList = lower(ctx.statementBlock().statementList());

      symTab.exit();
      return new FunctionDefinition(makePosition(ctx), symbol, paramList, statementList);
    }

  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StatementVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to
     * {@link DeclarationVisitor#visitArrayDeclaration(CruxParser.ArrayDeclarationContext)} which we
     * implement earlier.
     * 
     * @return an AST {@link VariableDeclaration}
     */

     @Override
     public Statement visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx) {
       return declarationVisitor.visitVariableDeclaration(ctx);
     }

    
    /**
     * Visit a parse tree assignment statement and create an AST {@link Assignment}
     * 
     * @return an AST {@link Assignment}
     */


     @Override
     public Statement visitAssignmentStatement(CruxParser.AssignmentStatementContext ctx) {
       //  public Assignment(Position position, Expression location, Expression value) {
       var location = ctx.designator().accept(expressionVisitor);


       var value = ctx.expression0().accept(expressionVisitor);

       return new Assignment(makePosition(ctx), location, value);

     }


    /**
     * Visit a parse tree assignment nosemi statement and create an AST {@link Assignment}
     * 
     * @return an AST {@link Assignment}
     */


     @Override
     public Statement visitAssignmentStatementNoSemi(CruxParser.AssignmentStatementNoSemiContext ctx) {
       var location = ctx.designator().accept(expressionVisitor);

       var value = ctx.expression0().accept(expressionVisitor);

       return new Assignment(makePosition(ctx), location, value);
     }


    /**
     * Visit a parse tree call statement and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExpressionVisitor#visitCallExpression(CruxParser.CallExpressionContext)} that we will
     * implement later.
     * 
     * @return an AST {@link Call}
     */

     @Override
     public Statement visitCallStatement(CruxParser.CallStatementContext ctx) {

       return expressionVisitor.visitCallExpression(ctx.callExpression());
     }

    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     * 
     * @return an AST {@link IfElseBranch}
     */

     @Override
     public Statement visitIfStatement(CruxParser.IfStatementContext ctx) {
      // IfElseBranch(Position position, Expression condition, StatementList thenBlock, StatementList elseBlock)

       var condition = ctx.expression0().accept(expressionVisitor);
       var thenBlock = lower(  ctx.statementBlock(0)   );
       var elseBlock = lower( ctx.statementBlock(1)   );

       return new IfElseBranch(makePosition(ctx), condition, thenBlock, elseBlock);
     }


    /**
     * Visit a parse tree for loop and create an AST {@link For}. You'll going to use a similar
     * techniques as {@link #visitIfStatement(CruxParser.IfStatementContext)} to decompose this
     * construction.
     * 
     * @return an AST {@link For}
     */

     @Override
     public Statement visitForStatement(CruxParser.ForStatementContext ctx) {
       //For(Position position, Assignment init, Expression cond, Assignment increment,
               //StatementList body)

       Assignment init = (Assignment) visitAssignmentStatement(ctx.assignmentStatement());
       Expression cond = ctx.expression0().accept(expressionVisitor);
       Assignment increment = (Assignment) visitAssignmentStatementNoSemi(ctx.assignmentStatementNoSemi());
       StatementList body = lower(ctx.statementBlock());

       return new For(makePosition(ctx), init, cond, increment, body);


     }


    /**
     * Visit a parse tree return statement and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     * 
     * @return an AST {@link Return}
     */

     @Override
     public Statement visitReturnStatement(CruxParser.ReturnStatementContext ctx) {
       //  public Return(Position position, Expression value) {

       var value = ctx.expression0().accept(expressionVisitor);

       return new Return(makePosition(ctx), value);
     }


    /**
     * Creates a Break node
     */

     @Override
     public Statement visitBreakStatement(CruxParser.BreakStatementContext ctx) {
       symTab.exit();

       return new Break(makePosition(ctx));
     }

  }

  private final class ExpressionVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expression0 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

    //  public OpExpr(Position position, Operation op, Expression left, Expression right)
     @Override
     public Expression visitExpression0(CruxParser.Expression0Context ctx) {
       if (ctx.op0() == null) {
         return ctx.expression1(0).accept(expressionVisitor);
       }

       //We expression1 op0 expression1 case
       Expression lhs = ctx.expression1(0).accept(expressionVisitor);
       Expression rhs = ctx.expression1(1).accept(expressionVisitor);

//       if(ctx.expression1().size() >= 2) {
//         rhs = ctx.expression1(1).accept(expressionVisitor);
//       } else {
//         rhs = lhs;
//       }

       CruxParser.Op0Context op0 = ctx.op0();


       Operation op;

       if (op0.EQUAL() != null) {
         op = Operation.EQ;
       } else if (op0.GREATER_EQUAL() != null){
         op = Operation.GE;
       }
       else if (op0.GREATER_THAN() != null){
         op = Operation.GT;
       }
       else if (op0.LESS_THAN() != null){

         op = Operation.LT;
       }
       else if (op0.LESSER_EQUAL() != null){
         op = Operation.LE;
       }
       else {
         op = Operation.NE;
       }
       return new OpExpr(makePosition(ctx), op, lhs, rhs);

     }

    /**
     * Parse Expression1 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */


     @Override
     public Expression visitExpression1(CruxParser.Expression1Context ctx) {
       //Handling Add or Sub
       if (ctx.op1() == null) {
         //We are expression2 case
         return ctx.expression2().accept(expressionVisitor);
       } else {
         //We expression1 op1 expression2 case
         Expression lhs = ctx.expression1().accept(expressionVisitor);
         Expression rhs = ctx.expression2().accept(expressionVisitor);
         CruxParser.Op1Context op1 = ctx.op1();

         Operation op;

         if (op1.ADD() != null) {
           op = Operation.ADD;
         } else if (op1.SUB() != null){
           op = Operation.SUB;
         }
         else {
           op = Operation.LOGIC_OR;
         }

         return new OpExpr(makePosition(ctx), op, lhs, rhs);
       }
     }

    /**
     * Parse Expression2 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

     @Override
     public Expression visitExpression2(CruxParser.Expression2Context ctx) {
       //Handling Mul or Div
       if (ctx.op2() == null) {
         //We are expression3 case
         return ctx.expression3().accept(expressionVisitor);
       } else {
         //We have the expression2 op2 expression3 case
         Expression lhs = ctx.expression2().accept(expressionVisitor);
         Expression rhs = ctx.expression3().accept(expressionVisitor);
         CruxParser.Op2Context op2 = ctx.op2();
         Operation op;

         if (op2.MUL() != null) {
           op = Operation.MULT;
         } else if (op2.DIV() != null){
           op = Operation.DIV;
         }
         else {
           op = Operation.LOGIC_AND;
         }

         return new OpExpr(makePosition(ctx), op, lhs, rhs);
       }
     }


    /**
     * Parse Expression3 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */

     @Override
     public Expression visitExpression3(CruxParser.Expression3Context ctx) {

       if (ctx.NOT() != null) {
         //System.out.println(ctx.expression3().getText());

         var exp = ctx.expression3().accept(expressionVisitor);

         return new OpExpr(makePosition(ctx), Operation.LOGIC_NOT, exp, null);
       }
       else if (ctx.designator() != null) {
         return ctx.designator().accept(expressionVisitor);
       }
       else if (ctx.callExpression() != null) {
         return ctx.callExpression().accept(expressionVisitor);
       }
       else if (ctx.literal() != null) {
         return ctx.literal().accept(expressionVisitor);
       }
       else {
         return ctx.expression0().accept(expressionVisitor);
       }
     }


    /**
     * Create an Call Node
     */

    @Override
    public Call visitCallExpression(CruxParser.CallExpressionContext ctx) {

      var funcName = ctx.Identifier().getText();
      var pos = makePosition(ctx);

      var symbol = symTab.lookup(pos, funcName);

      ArrayList<Expression> list = new ArrayList<Expression> ();


      var temp = ctx.expressionList().accept(expressionVisitor);
      for(CruxParser.Expression0Context context: ctx.expressionList().expression0()) {
        Expression node = context.accept(expressionVisitor);
        list.add(node);
      }

      return new Call(pos, symbol, list);

    }


    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */

    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
//      String name = ctx.getText();
//      Symbol symbol = getSymbol(name);
//      return new VarNode(symbol);
//
//      return null;

      String identifier = ctx.Identifier().getText();

      Expression idx = null;

      var base = symTab.lookup(makePosition(ctx), identifier);

      //  public ArrayAccess(Position position, Symbol base, Expression index) {
      if (ctx.expression0() != null) {
        idx = ctx.expression0().accept(expressionVisitor);



        return new ArrayAccess(makePosition(ctx), base, idx);
      }
      else {
        return new VarAccess(makePosition(ctx), base);
      }




    }

    /**
     * Create an Literal Node
     */

    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {

      if(ctx.getText().equals("true")) {
        return new LiteralBool(makePosition(ctx), true);
      }
      else if (ctx.getText().equals("false")) {
        return new LiteralBool(makePosition(ctx), false);
      }
      else {
        String number = ctx.getText();
        int i = Integer.parseInt(number);
        return new LiteralInt(makePosition(ctx), i);
      }
    }
  }
}
